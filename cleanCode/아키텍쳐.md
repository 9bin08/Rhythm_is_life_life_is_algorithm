클린한 아키텍쳐를 위한 생각들

## MVVM 패턴에서 View의 의미 생각해보기

- 보통 각 뷰는 독립적이여야 생각하는데 뷰들을 위한 뷰를 만드는 일은 안티패턴인듯 ?
- ViewModel와 view의 연결고리와 담당하는 역할의 경계 생각해보기 어디까지가 view인지
- view는 말그대로 view의 역할까지만

## 의존성

- 외부와 강하게 연결되어 있을 수록 변경에 취약함 의존성을 줄여주는 레이어를 한장두면 유연하게 유지보수가 가능해짐
- ex )

```javascript
// before
const videoStorage = {
  getVideo() {
    return JSON.parse(localStorage.getItem('saveVideoData')) || [];
  },
};
// after
export default class VideoStorage {
  #videos = JSON.parse(localStorage.getItem('saveVideoData')) || [];

  getVideo() {
    return this.#videos;
  }

  setVideo() {
    localStorage.setItem('saveVideoData', JSON.stringify(this.#videos));
  }
}
```

## 양방향 바인딩에 대한 생각

- 분명히 생산성를 높혀주는건 확실
- 하지만 요즘 dart를 사용하면서 느끼는 단점도 분명히 있다고 생각한다
- 함수형과 객체지향코드를 섞어서 남용, 일관된 코드 사용 방법론을 생각해볼 것
- 일관된 코드 사용이 아니라면 분명히 유지보수, 기능 확장 중 구렁텅이에 빠지는 경우가 있음.
- sync중 낭비되는 성능에 대해 생각 해볼것

## 완벽한 구조는 없다

- 완벽한 아키텍쳐는 없다. 진행중인 도메인의 성향과 기능에 따라 구조는 유연하게 바꾸면서 적용하는 것
- 에자일 + 유연한 아키텍쳐 구조의 조합 => 생산성 확대
- 지금 생각한 좋은 구조란 독립적이고 확장성이 용이하며 팀원들이 사용하기 쉬워야 한다
- 와이어프레임과 기획안은 추후에 높은 확률로 변경된다. 변하지 않는 서비스는 없다.

## 네이밍

- 간결한 용어사용보다 훨씬 중요한 것이 문맥에 따라 충분히 유추가능한 어휘 사용이다.
- 객체지향 경우 return 값을 네이밍만 보고 유추한다면 베스트
- 네이밍만 보고 목적을 정확하게 유추 가능해야함. 애메모호한 네이밍이나 네이밍에 타입을 넣는일은 절대 피할 것.

## 관심사 분리

- 함수는 한가지 기능을 명확하게 하는 것.
- 순수함수
- 오히려 빡시게 된 추상화와 패턴화가 가독성과 생산성을 해칠 수 있다. 적절한 선을 유지하는 것이 좋은 cowork
- 개인적으로 생각하는 함수 분리 분기는 1.로직이 10줄 이상 넘어가는 경우 2.두 번 이상 재사용 가능 한 경우 3. 명확한 기능을 담당하는 함수일 경우

## 상수

- 의미있게 사용되는 부분이라면 중복으로 사용을 안하더라도 상수화를 통해 의미를 부여하자
- 로컬스토리지에서 사용할 경우 key값 상수화가 가독성에 좋음

# 소소~

- attribute는 '고유속성'에 가까운 정적인 개념에 가깝다. 동적으로 변하는 '상태'에는 적합하지 않다.
- br태그 같은 경우 공식 문서에서도, <br />보다는 <br>을 사용하고 있다. /제거 지양
- 배열을 spread하는 것은 배열의 각 요소를 한 번씩 순회하는 비싼 작업. length만 체크하여 가능한 작업일 경우도 많다.
- for문을 some으로 refactor가능한 경우도 많다.
- 구조분해할당은 클린코드의 시작
- return에서 다시 return 으로 이어지는 코드는 가독성이 떨어지는듯 변수에 저장한다면 파악이 더욱 간결함
- CSS 의사 클래스와 CSS 의사요소를 구분하자. : vs ::
- reflow / 노드 추가 제거, 요소 위치 변경, 요소 크기 변경 (margin, padding, border, width, height 등), 페이지 초기 랜더링, 윈도우 리사이징
- repaint / 화면의 구조가 변경되지 않은, 화면 변화의 경우, css의 opacity, background-color, visibility, outline 속성들
- reflow 최소화 최대한 가장 하위노드만 변경하기, DOM 사용 최소화 하기
- is-a vs has-a 명백하게 작성
- input중 search 타입이 있음. 검색어를 입력할 수 있는 텍스트 필드 정의. 기능은 완전히 똑같지만 브라우저에 의해 다르게 표현
- search필드는 반드시 name 속성을 주어야하며 주지 않을 경우 서버로 제출x 주로q를 많이 사용함
- JSON.stringify를 사용하여 두 객체 같음을 판별할 경우 키의 순서가 바뀌면 검증 불가
- replaceChildren()
