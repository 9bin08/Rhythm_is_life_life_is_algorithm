1. Service locator
   - 서비스 로케이터 패턴을 사용하는 이유는 서비스의 직접적인 구체 클래스는 숨긴 채 어디에서나 서비스에 접근할 수 있게 하기 위함
   - 예를들면 메모리 할당, 로그, 난수 생성 등 드러나지 않아야하는 코드 부
   - 중계자를 두어 접근을 중계자를 통해
   - 인터페이스 구현 => 상속 => 접근
   - 중계자를 두기 때문에 이를 통해 테스트가 수월해짐
   - 외부 코드에 의존적, 한번 등록된 서비스는 쉽게 변경 할 수 없음
   - 서비스 로케이터 구조는 안티패턴 구조(서비스 로케이터를 사용했을 때 나타나는 문제는 클래스의 의존성을 숨긴다는 점입니다. 다시 말해 컴파일 중에는 오류가 나타나지 않았지만 런타임에서는 오류가 발생할 여지가 있다는 이야기입니다. 이전에 작성한 코드와 호환이 되지 않는 방식으로 코드를 변경했다고 가정해봅시다. 어느 클래스가 어떤 클래스에 의존하고 있는지 명확하게 들어나지 않고 있는 상황에서는 그 변경이 어느 클래스에 영향을 미치는지 확인하기 어렵습니다. 그로 인해서 새로운 코드를 작성할 때마다 어디가 고장나는지 정확히 알 수 없어서 유지보수가 더 어려워질 수 밖에 없습니다.)
   - 의존성 주입 패턴 DI
